{
  "name": "mimefuncs",
  "description": "Encode and decode quoted printable and base64 strings",
  "version": "0.3.5",
  "main": "src/mimefuncs",
  "homepage": "https://github.com/whiteout-io/mimefuncs",
  "repository": {
    "type": "git",
    "url": "git://github.com/whiteout-io/addressparser.git"
  },
  "license": "MIT",
  "keywords": [
    "MIME",
    "Base64",
    "Quoted-Printable"
  ],
  "author": {
    "name": "Andris Reinman",
    "email": "andris@kreata.ee"
  },
  "scripts": {
    "test": "grunt"
  },
  "dependencies": {
    "wo-stringencoding": "~0.1.1"
  },
  "devDependencies": {
    "chai": "~1.8.1",
    "grunt": "~0.4.1",
    "grunt-mocha-phantomjs": "~0.4.0",
    "grunt-contrib-connect": "~0.6.0",
    "grunt-contrib-jshint": "~0.8.0",
    "grunt-mocha-test": "~0.10.0",
    "mocha": "~1.16.2",
    "phantomjs": "~1.9.7-1",
    "requirejs": "~2.1.10",
    "amdefine": "^0.1.0"
  },
  "readme": "# MIME Functions\n\n`mimefuncs` allows you to encode and decode between different MIME related encodings. Quoted-Printable, Base64 etc.\n\nAll input can use any charset (in this case, the value must not be a string but an arraybuffer of Uint8Array) but output is always unicode.\n\n[![Build Status](https://travis-ci.org/whiteout-io/mimefuncs.png)](https://travis-ci.org/whiteout-io/mimefuncs)\n\n## StringEncoding API\n\nThis module requires `TextEncoder` and `TextDecoder` to exist as part of the StringEncoding API (see: [MDN](https://developer.mozilla.org/en-US/docs/WebAPI/Encoding_API) [whatwg.org](http://encoding.spec.whatwg.org/#api)). Firefox 19+ is basically the only browser that supports this at the time of writing, while [Chromium in canary, not stable](https://code.google.com/p/chromium/issues/detail?id=243354). Luckily, [there is a polyfill](https://github.com/whiteout-io/stringencoding)!\n\n## Installation\n\n### [npm](https://www.npmjs.org/):\n\n    npm install --save mimefuncs\n\n## Usage\n\n### AMD\n\nRequire [mimefuncs.js](src/mimefuncs.js) as `mimefuncs`\n\n### Global context\n\nInclude file [mimefuncs.js](src/mimefuncs.js) on the page.\n\n```html\n<script src=\"mimefuncs.js\"></script>\n```\n\nThis exposes global variable `mimefuncs`\n\n## Methods\n\n### foldLines\n\nFolds a long line according to the RFC 5322 <http://tools.ietf.org/html/rfc5322#section-2.1.1>\n\n    mimefuncs.foldLines(str [, lineLengthMax[, afterSpace]]) -> String\n\n  * **str** - String to be folded\n  * **lineLengthMax** - Maximum length of a line (defaults to 76)\n  * **afterSpace** - If true, leave a space in th end of a line\n\nFor example:\n\n    mimefuncs.foldLines('Content-Type: multipart/alternative; boundary=\"----zzzz----\"')\n\nresults in\n\n    Content-Type: multipart/alternative;\n         boundary=\"----zzzz----\"\n\n### mimeWordEncode\n\nEncodes a string into mime encoded word format <http://en.wikipedia.org/wiki/MIME#Encoded-Word>  (see also `mimeWordDecode`)\n\n    mimefuncs.mimeWordEncode(str [, mimeWordEncoding[, maxLength[, fromCharset]]]) -> String\n\n  * **str** - String or Uint8Array to be encoded\n  * **mimeWordEncoding** - Encoding for the mime word, either Q or B (default is 'Q')\n  * **maxLength** - If set, split mime words into several chunks if needed\n  * **fromCharset** - If the first parameter is a typed array, use this encoding to decode the value to unicode\n\nFor example:\n\n    mimefuncs.mimeWordEncode('See on õhin test', 'Q');\n\nBecomes with UTF-8 and Quoted-printable encoding\n\n    =?UTF-8?Q?See_on_=C3=B5hin_test?=\n\n### mimeWordDecode\n\nDecodes a string from mime encoded word format (see also `mimeWordEncode`)\n\n    mimefuncs.mimeWordDecode(str) -> String\n\n  * **str** - String to be decoded\n\nFor example\n\n    mimefuncs.mimeWordDecode('=?UTF-8?Q?See_on_=C3=B5hin_test?=');\n\nwill become\n\n    See on õhin test\n\n### continuationEncode\n\nEncodes and splits a header param value according to [RFC2231](https://tools.ietf.org/html/rfc2231#section-3) Parameter Value Continuations.\n\n    mimefuncs.continuationEncode(key, str, maxLength [, fromCharset]) -> Array\n\n  * **key** - Parameter key (eg. `filename`)\n  * **str** - String or an Uint8Array value to encode\n  * **maxLength** - Maximum length of the encoded string part (not line length). Defaults to 50\n  * **fromCharset** - If `str` is a typed array, use this charset to decode the value to unicode before encoding\n\nThe method returns an array of encoded parts with the following structure: `[{key:'...', value: '...'}]`\n\n#### Example\n\n```\nmimefuncs.continuationEncode('filename', 'filename õäöü.txt', 20);\n->\n[ { key: 'filename*0*', value: 'utf-8\\'\\'filename%20' },\n  { key: 'filename*1*', value: '%C3%B5%C3%A4%C3%B6' },\n  { key: 'filename*2*', value: '%C3%BC.txt' } ]\n```\n\nThis can be combined into a properly formatted header:\n\n```\nContent-disposition: attachment; filename*0*=\"utf-8''filename%20\"\n  filename*1*=\"%C3%B5%C3%A4%C3%B6\"; filename*2*=\"%C3%BC.txt\"\n```\n\n### quotedPrintableEncode\n\nEncodes a string into Quoted-printable format (see also `quotedPrintableDecode`). Maximum line\nlength for the generated string is 76 + 2 bytes.\n\n    mimefuncs.quotedPrintableEncode(str [, fromCharset]) -> String\n\n  * **str** - String or an Uint8Array to mime encode\n  * **fromCharset** - If the first parameter is a typed array, use this charset to decode the value to unicode before encoding\n\n### quotedPrintableDecode\n\nDecodes a string from Quoted-printable format  (see also `quotedPrintableEncode`).\n\n    mimefuncs.quotedPrintableDecode(str [, fromCharset]) -> String\n\n  * **str** - Mime encoded string\n  * **fromCharset** - Use this charset to decode mime encoded string to unicode\n\n### base64Encode\n\nEncodes a string into Base64 format (see also `base64Decode`). Maximum line\nlength for the generated string is 76 + 2 bytes.\n\n    mimefuncs.base64Encode(str [, fromCharset]) -> String\n\n  * **str** - String or an Uint8Array to base64 encode\n  * **fromCharset** - If the first parameter is a typed array, use this charset to decode the value to unicode before encoding\n\n### base64Decode\n\nDecodes a string from Base64 format (see also `base64Encode`) to an unencoded unicode string.\n\n    mimefuncs.base64Decode(str [, fromCharset]) -> String\n\n  * **str** Base64 encoded string\n  * **fromCharset** Use this charset to decode base64 encoded string to unicode\n\n### base64.decode\n\nDecodes a string from Base64 format to an Uint8Array.\n\n    mimefuncs.base64.decode(str) -> Uint8Array\n\n  * **str** Base64 encoded string\n\n### mimeWordEncode\n\nEncodes a string to a mime word.\n\n    mimefuncs.mimeWordEncode(str[, mimeWordEncoding[, maxLength[, fromCharset]]]) -> String\n\n  * **str** - String or Uint8Array to be encoded\n  * **mimeWordEncoding** - Encoding for the mime word, either Q or B (default is 'Q')\n  * **maxLength** - If set, split mime words into several chunks if needed\n  * **fromCharset** - If the first parameter is a typed array, use this charset to decode the value to unicode before encoding\n\n### mimeWordsEncode\n\nEncodes non ascii sequences in a string to mime words.\n\n    mimefuncs.mimeWordsEncode(str[, mimeWordEncoding[, maxLength[, fromCharset]]]) -> String\n\n  * **str** - String or Uint8Array to be encoded\n  * **mimeWordEncoding** - Encoding for the mime word, either Q or B (default is 'Q')\n  * **maxLength** - If set, split mime words into several chunks if needed\n  * **fromCharset** - If the first parameter is a typed array, use this charset to decode the value to unicode before encoding\n\n### mimeWordDecode\n\nDecodes a complete mime word encoded string\n\n    mimefuncs.mimeWordDecode(str) -> String\n\n  * **str** - String to be decoded. Mime words have charset information included so need to specify it here\n\n### mimeWordsDecode\n\nDecodes a string that might include one or several mime words. If no mime words are found from the string, the original string is returned\n\n    mimefuncs.mimeWordsDecode(str) -> String\n\n  * **str** - String to be decoded\n\n### headerLineEncode\n\nEncodes and folds a header line for a MIME message header. Shorthand for `mimeWordsEncode` + `foldLines`.\n\n    mimefuncs.headerLineEncode(key, value[, fromCharset])\n\n  * **key** - Key name, will not be encoded\n  * **value** - Value to be encoded\n  * **fromCharset** - If the `value` parameter is a typed array, use this charset to decode the value to unicode before encoding\n\n### headerLineDecode\n\nUnfolds a header line and splits it to key and value pair. The return value is in the form of `{key: 'subject', value: 'test'}`. The value is not mime word decoded, you need to do your own decoding based on the rules for the specific header key.\n\n    mimefuncs.headerLineDecode(headerLine) -> Object\n\n  * **headerLine** - Single header line, might include linebreaks as well if folded\n\n### headerLinesDecode\n\nParses a block of header lines. Does not decode mime words as every header\nmight have its own rules (eg. formatted email addresses and such).\n\nReturn value is an object of headers, where header keys are object keys. NB! Several values with the same key make up an array of values for the same key.\n\n    mimefuncs.headerLinesDecode(headers) -> Object\n\n  * **headers** - Headers string\n\n### fromTypedArray\n\nConverts an `ArrayBuffer` or `Uint8Array` value to 'binary' string.\n\n    mimefuncs.fromTypedArray(data) -> String\n\n  * **data** - an `ArrayBuffer` or `Uint8Array` value\n\n### toTypedArray\n\nConverts a 'binary' string to an `Uint8Array` object.\n\n    mimefuncs.toTypedArray(data) -> Uint8Array\n\n  * **data** - a 'binary' string\n\n### parseHeaderValue\n\nParses a header value with `key=value` arguments into a structured object. Useful when dealing with\n`content-type` and such.\n\n    parseHeaderValue(valueString) -> Object\n\n  * **valueString** - a header value without the key\n\nExample\n\n```javascript\nparseHeaderValue('content-type: text/plain; CHARSET=\"UTF-8\"');\n```\n\nOutputs\n\n```json\n{\n    \"value\": \"text/plain\",\n    \"params\": {\n        \"charset\": \"UTF-8\"\n    }\n}\n```\n\n## Hands on\n\n```bash\ngit clone git@github.com:whiteout-io/mimefuncs.git\ncd mimefuncs\nnpm install && npm test\n```\n\n## License\n\n```\nCopyright (c) 2013 Andris Reinman\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.```\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/whiteout-io/addressparser/issues"
  },
  "_id": "mimefuncs@0.3.5",
  "_from": "mimefuncs@"
}
